-- =============================================================================
-- Analysis: Product Profitability
-- Purpose:
--   Identify products that generate sales but result in negative profit.
--   This helps highlight items that might reduce overall profitability.
--
-- Notes:
--   - Aggregate sales and profit by product_name.
--   - Use HAVING to filter products with total profit < 0.
--   - No arbitrary sales threshold is applied (exploratory).
--
-- Expected outcome:
--   List of product names with negative profit and their sales totals.
-- =============================================================================
SELECT
	product_name,
	sum (sales) AS total_sales,
	sum (profit) AS total_profit,
	round(sum (profit) / sum (sales), 3) AS profit_margin
FROM
	superstore_dataset
GROUP BY
		product_name
HAVING
	sum (profit) < 0
ORDER BY
	total_sales DESC;

-- =============================================================================
-- Analysis: Category and Sub-Category Performance
-- Purpose:
--   Compare sales, profit, and profit margin across product categories
--   and sub-categories to identify performance differences.
--
-- Approach:
--   - Aggregate sales and profit by category and sub-category.
--   - Calculate profit margin as profit divided by sales.
--   - Order results to observe high- and low-performing groups.
--
-- Insight focus:
--   Differences in profitability are not always aligned with sales volume.
-- =============================================================================
SELECT
	category,
	subcategory,
	sum (sales) AS total_sales,
	sum (profit) AS total_profit,
	round (sum (profit) * 100.0 / sum (sales), 3) AS profit_margin
FROM
	superstore_dataset
GROUP BY
	category,
	subcategory
ORDER BY
	total_sales DESC


-- =============================================================================
-- Analysis: Discount Impact Analysis
-- Purpose:
--   Examine the relationship between discount levels and profitability.
--
-- Data preparation:
--   - Clean discount values stored as TEXT.
--   - Replace comma decimal separators with dots for numeric conversion.
--
-- Approach:
--   - Group transactions into discount ranges (bins).
--   - Compare average sales, profit, and profit margin across discount bins.
--
-- Insight focus:
--   Higher discount levels tend to reduce profit margins.
-- =============================================================================
WITH base AS (
	SELECT
		CAST(replace (discount,',', '.') AS REAL) AS discount_value,
		sales, 
		profit
	FROM
		superstore_dataset
),
discount_binning AS (
	SELECT
		CASE
			WHEN discount_value = 0 THEN 'No discount'
			WHEN discount_value > 0 AND discount_value <= 0.2 THEN 'Low discound'
			WHEN discount_value > 0.2 AND discount_value <= 0.5 THEN 'Medium discount'
			WHEN discount_value > 0.5 THEN 'High discount'
			ELSE 'Unknown' 
		END AS category_discount,
		sales,
		profit
	FROM 
		base
)
SELECT
	category_discount,
	sum (sales) AS total_sales,
	sum (profit) AS total_profit,
	round(sum (profit) *100.0 / sum(sales), 3) AS profit_margin
FROM
	discount_binning
GROUP BY
	category_discount
ORDER BY
	category_discount

-- =============================================================================
-- Analysis: Customer Segmentation
-- Purpose:
--   Segment customers based on purchasing behavior using transaction
--   frequency and total sales contribution.
--
-- Approach:
--   - Aggregate number of orders and total sales per customer.
--   - Use average transaction metrics for simple segmentation.
--
-- Insight focus:
--   Customers show varying purchasing patterns that contribute
--   differently to overall sales.
-- =============================================================================
WITH customer_summary AS (
	SELECT
		customer,
		sum(sales) AS total_sales,
		count (order_id) AS frequency_order
	FROM
		superstore_dataset
	GROUP BY
		customer 
),
average_frequency AS (
	SELECT
		avg(frequency_order) AS AVG_frequency_order
	FROM
		customer_summary
),
customer_segmentation AS (
	SELECT
		cs.customer,
		cs.total_sales,
		cs.frequency_order,
		CASE
			WHEN cs.frequency_order < af.AVG_frequency_order THEN 'Low value'
			WHEN cs.frequency_order BETWEEN af.AVG_frequency_order AND af.AVG_frequency_order * 1.5  THEN 'Medium value'
			WHEN cs.frequency_order > af.AVG_frequency_order * 1.5 THEN 'High value'
			ELSE 'Unknown' 
		END AS customer_segment
	FROM customer_summary cs
	CROSS JOIN average_frequency af
)
SELECT
	*
FROM
	customer_segmentation
ORDER BY
	total_sales DESC;

-- =============================================================================
-- Analysis: Regional Performance Analysis
-- Purpose:
--   Evaluate sales and profit performance across regions and cities.
--
-- Approach:
--   - Aggregate profit at the city and region level.
--   - Apply window functions to rank cities within each region.
--
-- Insight focus:
--   Regional and city-level performance varies, highlighting
--   geographic differences in profitability.
-- =============================================================================
WITH region_profit AS (
	SELECT
		region, city,
		sum (profit) AS total_profit
	FROM
		superstore_dataset
	GROUP BY
		region, city
),
rank_region AS (
	SELECT
		*,
		rank () OVER(PARTITION BY region ORDER BY total_profit DESC) AS rn
	FROM
		region_profit
) 
SELECT
	region, city,
	total_profit
FROM
	rank_region
WHERE rn = 1

-- =============================================================================
-- Analysis: Sales Trend Analysis
-- Purpose:
--   Analyze monthly sales trends over time.
--
-- Data preparation:
--   - Parse order dates stored in DD/MM/YYYY text format.
--   - Convert date components using SQL string functions.
--
-- Approach:
--   - Aggregate sales by month and year.
--   - Observe changes and patterns over time.
--
-- Insight focus:
--   Transaction data reveals recurring monthly sales patterns.
-- =============================================================================
WITH sales_month AS (
SELECT
	substr (order_date, 7, 4) || '-' || substr (order_date, 4, 2) AS month,
	sum (sales) AS total_sales,
	sum (profit) AS total_profit
FROM
	superstore_dataset
GROUP BY
	month
),
sales_previous AS (
	SELECT
		*,
		lag(total_sales) OVER (ORDER BY month) AS previous_sales
	FROM 
		sales_month
		)
SELECT
	month,
	total_sales,
	total_profit,
	round((total_sales - previous_sales )* 100.0 / 
	nullif(previous_sales, 0), 3) AS sales_growth,
	CASE
		WHEN previous_sales is NULL THEN 'first Trend'
		WHEN total_sales < previous_sales THEN 'Downward Trend'
		WHEN total_sales > previous_sales THEN 'Upward Trend'
		ELSE 'Stable'
	END AS trend_segment	
FROM
	sales_previous
ORDER BY
	month;

